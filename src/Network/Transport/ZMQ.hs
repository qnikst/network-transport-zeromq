{-# LANGUAGE DeriveGeneric, StandaloneDeriving, OverloadedStrings, DeriveDataTypeable #-}
module Network.Transport.ZMQ
  ( -- * Main API
    createTransport       -- :: ZMQParameters -> ByteString -> IO (Either ZMQError Transport)
  , ZMQParameters(..)     
  , ZMQAuthType(..)
  , defaultZMQParameters  -- :: ZMQParameters
  -- * Internals
  , createTransportEx
  , breakConnection
  -- * $Design
  ) where

import Network.Transport.ZMQ.Types

import           Control.Applicative
import           Control.Concurrent
       ( yield
       , threadDelay
       )
import qualified Control.Concurrent.Async as Async
import           Control.Concurrent.MVar
import           Control.Concurrent.STM
import           Control.Concurrent.STM.TMChan
import           Control.Monad
      ( void
      , forever
      , unless
      , join
      , forM_
      , foldM
      , replicateM
      , when
      , (<=<)
      )
import           Control.Exception 
      ( evaluate
      , AsyncException
      )
import           Control.Monad.Catch
      ( finally
      , bracket
      , try
      , throwM
      , Exception
      , SomeException
      , fromException
      , mask
      )
import           Data.Binary
import           Data.ByteString (ByteString)
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.ByteString.Char8 as B8
import           Data.IORef
      ( newIORef
      , modifyIORef
      , readIORef
      , writeIORef
      )
import           Data.List.NonEmpty
import           Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
-- import           Data.Set (Set)
import qualified Data.Set as Set
import           Data.Typeable
import           Data.Traversable
import           Data.Void
import           GHC.Generics
      ( Generic )

import Network.Transport
import Network.Transport.ZMQ.Types
import           System.ZMQ4
      ( Context )
import qualified System.ZMQ4 as ZMQ
import qualified System.ZMQ4.Utils   as ZMQ

import Text.Printf

--------------------------------------------------------------------------------
--- Internal datatypes                                                        --
--------------------------------------------------------------------------------
-- $design
--
-- In the zeromq backend we are using following address scheme:
--
-- tcp://host:port/
--  |       |   |
--  |       +---+---------------- can be configured by user, one host,
--  |                             port pair per distributed process
--  |                             instance
--  +---------------------------- In feature it will be possible to add
--                                another hosts.
--
-- Transport specifies host that will be used, and port will be
-- automatically generated by the transport.                               
--
-- Connection reliability.
--
-- Currently only reliable connections are supportred (so in case if you
-- pass want unreliable connection it will also be reliable), this will be
-- changed in future, by creating additional address for each endpoint.
--
-- Network-transport-zeromq maintains 1 thread for each endpoint that is
-- used to read incomming requests, all send and connection requests are
-- handled from the user thread
--
-- Connections.
--    0MQ automatically handles connection liveness. This breaks some
--    assumptions about connectivity and leads to problems with connection
--    handling.
--


-- $socket-system socket system is differ from the one that is used in
-- network-transport-tcp:
--
-- Each endpoint obtains one pull socket and push socket for each remote
-- end point, all lightweight threads abrigged into one heavyweight
-- connection.
--
-- Virually connections looks like the following plot:
--
-- +------------------+                                +--------------+
-- |  Endpoint        |                                |  Endpoint    |
-- |                  |                                |              |
-- |               +------+                        +------+           |
-- |               | pull |<-----------------------| push |           |
-- +               +------+                        +------+           |
-- |                  |     +--------------------+     |              |
-- +               +------+/~~~~ connection 1 ~~~~\+------+           |
-- |               | push |~~~~~ connection 2 ~~~~~| pull |           |
-- |               +------+\                      /+------+           |
-- |                  |     +--------------------+     |              |
-- +------------------+                                +--------------+
--
-- Physically zeromq may choose better representations and mapping on
-- a real connections.
--
-- Such design allowes to do not allow to distinguish messages from
-- different remote endpoint, so as a result it leads to different message
-- passing scheme

-- Naming conventions.
-- api* -- functions that can be called by user
-- localEndPoint -- internal functions that are used in endpoints
-- remoteEndPoint -- internal functions that are used in endpoints
--
-- Transport 
--   |--- Valid                transport itself
--   |      |--- newEndpoint
--   |      |--- close         
--   |--- Closed
--
-- LocaEndPoint
-- RemoteEndPoint
-- Connection

-- Connection closing procedure.
-- Once endpoint is gracefully closed by user or by transport close
-- RemoteEndPoint goes into 'RemoteEndPointClosing' state and sends
-- a message to remote endpoint if link is known as alive, in 
-- RemoteEndPointClosing all messages are ignored and EndPointClosed
-- is returned. Uppon a EndPointClose delivery endpoint replies with
-- EndPointClose message, and starts cleanup procedure (marking link
-- as not alive). When endpoint receives EndPointCloseOk message it
-- moved RemoteEndPoint to close state and removes all data structures.
-- Together with marking a endpoint as closed asynchronous timeout is
-- set, and if EndPointCloseOk is not delivered withing that timeperiod
-- EndPoint is closed.
-- 
-- endpoint-1                                 endpoint-2
--  1. mark as closing
--  [RemoteEndPoint:Closing] ----endPointClose->    [remoteEndPoint:Valid]
--                                            2. mark as closed
--                           <-endPointCloseOk-     [remoteEndPoint:Closed]
--  2. mark as closed
--  [RemoteEndPoint:Closed]                   4. cleanup remote end point
--
-- EndPoint can be closed in a two ways: normally and abnormally (in case
-- of exception or invariant vionation on a remove side). If EndPoint is
-- closed normally all opened connections will recevice ConnectionClosed 
-- events, otherwise.

-- | Messages
data ZMQMessage
      = MessageConnect !EndPointAddress -- ^ Connection greeting
      | MessageInitConnection !EndPointAddress !ConnectionId !Reliability
      | MessageInitConnectionOk !EndPointAddress !ConnectionId !ConnectionId
      | MessageCloseConnection !ConnectionId
      | MessageData !ConnectionId
      | MessageEndPointClose !EndPointAddress !Bool
      | MessageEndPointCloseOk !EndPointAddress
      deriving (Generic)

{- 
instance Binary ZMQMessage where
  put (MessageConnect ep) = putWord64le 0 >> put ep
  put (MessageInitConnection ep cid rel)   = putWord64le 2 >> put ep >> put cid >> put rel
  put (MessageInitConnectionOk ep cid rid) = putWord64le 3 >> put ep >> put cid >> put rid
  put (MessageCloseConnection cid)         = putWord64le 4 >> put cid
  put (MessageEndPointClose ep)            = putWord64le 5 >> put ep
  put (MessageData cid)                    = putWord64le cid
  get = do x <- getWord64be
           case x of
             0 -> MessageConnect <$> get
             2 -> MessageInitConnection   <$> get <*> get <*> get
             3 -> MessageInitConnectionOk <$> get <*> get <*> get
             4 -> MessageCloseConnection  <$> get
             5 -> MessageEndPointClose    <$> get
             6 -> MessageData <$> pure x

reservedConnectionId = 7
-}

instance Binary ZMQMessage

data ZMQError = InvariantViolation String
              | IncorrectState String
              | ConnectionFailed
              deriving (Typeable, Show)

instance Exception ZMQError

createTransport :: ZMQParameters
                -> ByteString
                -> IO (Either (TransportError Void) Transport)
createTransport z b = fmap (fmap snd) (createTransportEx z b)

createTransportEx :: ZMQParameters    -- ^ Transport features.
                  -> ByteString       -- ^ Host name or IP address
                  -> IO (Either (TransportError Void) (ZMQTransport, Transport))
createTransportEx params host = do
    ctx       <- ZMQ.context
    transport <- ZMQTransport 
    	<$> pure addr 
        <*> newMVar (TransportValid $ ValidTransportState ctx Map.empty)
    return $ Right (transport, Transport
      { newEndPoint    = apiNewEndPoint params transport
      , closeTransport = apiTransportClose transport
      })
  where
    addr = B.concat ["tcp://", host]

-- Synchronous
apiTransportClose :: ZMQTransport -> IO ()
apiTransportClose transport = do
    old <- swapMVar (_transportState transport) TransportClosed
    case old of
      TransportClosed -> return ()
      TransportValid (ValidTransportState ctx m) -> do
        forM_ (Map.elems m) $ apiCloseEndPoint transport
	ZMQ.term ctx

apiNewEndPoint :: ZMQParameters -> ZMQTransport -> IO (Either (TransportError NewEndPointErrorCode) EndPoint)
apiNewEndPoint params transport = do
--    printf "[transport] endpoint create\n"
    elep <- modifyMVar (_transportState transport) $ \case
       TransportClosed -> return (TransportClosed, Left $ TransportError NewEndPointFailed "Transport is closed.")
       v@(TransportValid i@(ValidTransportState ctx _)) -> do
         eEndPoint <- endPointCreate params ctx (B8.unpack addr)
         case eEndPoint of
           Right (port, ep, chan) -> return 
	   	  ( TransportValid i{_transportEndPoints = Map.insert (localEndPointAddress ep) ep (_transportEndPoints i)}
                  , Right (ep, ctx, chan))
           Left _ -> return (v, Left $ TransportError NewEndPointFailed "Failed to create new endpoint.")
    case elep of
      Right (ep,ctx, chOut) ->
        return $ Right $ EndPoint
          { receive = atomically $ do
              mx <- readTMChan chOut
              case mx of
                Nothing -> error "channel is closed"
                Just x  -> return x
          , address = localEndPointAddress ep
          , connect = apiConnect ctx ep
          , closeEndPoint = apiCloseEndPoint transport ep
          , newMulticastGroup     = return . Left $
              TransportError NewMulticastGroupUnsupported "Multicast not supported"
          , resolveMulticastGroup = return . return . Left $
              TransportError ResolveMulticastGroupUnsupported "Multicast not supported"
          }
      Left x -> return $ Left x
  where
    addr = transportAddress transport

-- | Asynchronous operation, shutdown of the remote end point may take a while
apiCloseEndPoint :: ZMQTransport
                 -> LocalEndPoint
		 -> IO ()
apiCloseEndPoint transport lep = do
--    printf "[%s][go] close endpoint\n"
--           (B8.unpack $ endPointAddressToByteString $ _localEndPointAddress lep)
    old <- readMVar (localEndPointState lep)
    case old of
      LocalEndPointValid (ValidLocalEndPoint x _ _ threadId _) -> do
        -- close channel, no events will be received
        atomically $ do
          writeTMChan x EndPointClosed
          closeTMChan x
        Async.cancel threadId
        void $ Async.waitCatch threadId         
      LocalEndPointClosed -> return ()
    modifyMVar_ (_transportState transport) $ \case
      TransportClosed  -> return TransportClosed 
      TransportValid v -> return $ TransportValid
        v{_transportEndPoints = Map.delete (localEndPointAddress lep) (_transportEndPoints v)}

endPointCreate :: ZMQParameters
               -> Context
               -> String
               -> IO (Either (TransportError NewEndPointErrorCode) (Int,LocalEndPoint, TMChan Event))
endPointCreate params ctx address = do
    em <- try $ accure
    case em of
      Right (port, pull) -> do
          chOut <- newTMChanIO
          lep   <- LocalEndPoint <$> pure (EndPointAddress $ B8.pack (address ++ ":" ++ show port))
                                 <*> newEmptyMVar
                                 <*> pure port
          opened <- newIORef True
          thread <- mask $ \restore ->
             Async.async $ (restore (receiver pull lep chOut)) 
                           `finally` finalizeEndPoint lep port pull
          putMVar (localEndPointState lep) $ LocalEndPointValid 
            (ValidLocalEndPoint chOut (Counter 0 Map.empty) Map.empty thread opened)
          return $ Right (port, lep, chOut)
      Left (_e::SomeException)  -> do
          return $ Left $ TransportError NewEndPointInsufficientResources "no free sockets"
  where

    finalizer pull ourEp = forever $ do
      (cmd:_) <- ZMQ.receiveMulti pull
      case decode' cmd of
        MessageEndPointCloseOk theirAddress ->  getRemoteEndPoint ourEp theirAddress >>= \case
          Nothing -> return ()
          Just rep -> do
            state <- swapMVar (remoteEndPointState rep) RemoteEndPointClosed
            closeRemoteEndPoint ourEp rep state
        _ -> return () -- XXX: send exception

    receiver :: ZMQ.Socket ZMQ.Pull
             -> LocalEndPoint
             -> TMChan Event
	     -> IO ()
    receiver pull ourEp chan = forever $ do
      (cmd:msgs) <- ZMQ.receiveMulti pull
      case decode' cmd of
        MessageData idx -> atomically $ writeTMChan chan (Received idx msgs)
        MessageConnect theirAddress -> do
--          printf "[%s] message connect from %s\n"
--                 (B8.unpack $ endPointAddressToByteString ourAddr)
--                 (B8.unpack $ endPointAddressToByteString theirAddress)
          void $ createOrGetRemoteEndPoint ctx ourEp theirAddress
        MessageInitConnection theirAddress theirId rel -> do
--        printf "[%s] message init connection from %s\n"
--                (B8.unpack $ endPointAddressToByteString ourAddr)
--                (B8.unpack $ endPointAddressToByteString theirAddress)
          join $ do
            modifyMVar (localEndPointState ourEp) $ \case
                LocalEndPointValid v ->
                    case theirAddress `Map.lookup` r of
                      Nothing -> return (LocalEndPointValid v, throwM $ InvariantViolation "Remote endpoint should exist.")
                      Just rep -> modifyMVar (remoteEndPointState rep) $ \case
                          RemoteEndPointFailed -> throwM $ InvariantViolation "RemoteEndPoint should be valid."
                          RemoteEndPointClosed -> throwM $ InvariantViolation "RemoteEndPoint should be valid."
                          RemoteEndPointClosing{} -> throwM $ InvariantViolation "RemoteEndPoint should be valid."
                          w@RemoteEndPointValid{} -> do
                            conn <- ZMQConnection <$> pure ourEp
                                                  <*> pure rep
                                                  <*> pure rel
                                                  <*> newMVar (ZMQConnectionValid $ ValidZMQConnection i)
                                                  <*> newEmptyMVar
                            w' <- register (succ i) w
                            return ( w'
                                   , ( LocalEndPointValid v{ _localEndPointConnections = Counter (succ i) (Map.insert (succ i) conn m) }
                                     , return ())
                                   )
                          z@(RemoteEndPointPending w) -> do
                            conn <- ZMQConnection <$> pure ourEp
                                                  <*> pure rep
                                                  <*> pure rel
                                                  <*> newMVar (ZMQConnectionValid $ ValidZMQConnection i)
                                                  <*> newEmptyMVar
                            modifyIORef w (\xs -> (register (succ i))  : xs)
                            return ( z
                                   , ( LocalEndPointValid v{ _localEndPointConnections = Counter (succ i) (Map.insert (succ i) conn m) }
                                     , return ())
                                   )
                  where
                    r = _localEndPointRemotes v
                    (Counter i m) = _localEndPointConnections v
                _ -> throwM $ InvariantViolation "RemoteEndPoint should be valid."
          where
            register i RemoteEndPointFailed = do
              atomically $ do
                writeTMChan chan (ConnectionOpened i rel theirAddress)
                writeTMChan chan (ConnectionClosed i)
              return RemoteEndPointFailed
            register i RemoteEndPointClosed = do
              atomically $ do
                writeTMChan chan (ConnectionOpened i rel theirAddress)
                writeTMChan chan (ConnectionClosed i)                        
              return RemoteEndPointClosed
            register i (RemoteEndPointClosing x) = do
              atomically $ do
                writeTMChan chan (ConnectionOpened i rel theirAddress)
                writeTMChan chan (ConnectionClosed i)
              return $ RemoteEndPointClosing x
            register _ RemoteEndPointPending{} = throwM $ InvariantViolation "RemoteEndPoint can't be pending."
            register i (RemoteEndPointValid v@(ValidRemoteEndPoint sock _ s _)) = do
              ZMQ.send sock [] $ encode' (MessageInitConnectionOk ourAddr theirId i)
              atomically $ writeTMChan chan (ConnectionOpened i rel theirAddress)
              return $ RemoteEndPointValid
                v{_remoteEndPointIncommingConnections = Set.insert i s}
        MessageCloseConnection idx -> join $ do
--          printf "[%s] message init connection: %i\n"
--                 (B8.unpack $ endPointAddressToByteString ourAddr)
--                 idx
          modifyMVar (localEndPointState ourEp) $ \case
            LocalEndPointValid v ->
                case idx `Map.lookup` m of
                  Nothing  -> return (LocalEndPointValid v, return ())
                  Just conn -> do
                    old <- swapMVar (connectionState conn) ZMQConnectionFailed
                    return ( LocalEndPointValid v{ _localEndPointConnections = Counter i (idx `Map.delete` m)}
                           , case old of
                               ZMQConnectionFailed -> return ()
                               ZMQConnectionInit -> return  () -- throwM InvariantViolation
                               ZMQConnectionClosed -> return ()
                               ZMQConnectionValid (ValidZMQConnection _) -> do
                                  atomically $ writeTMChan chan (ConnectionClosed idx)
                                  connectionCleanup (connectionRemoteEndPoint conn) idx)
              where
                (Counter i m) = _localEndPointConnections v
	    LocalEndPointClosed -> return (LocalEndPointClosed, return ())
        MessageInitConnectionOk theirAddress ourId theirId -> do
--          printf "[%s] message init connection ok: %i -> %i\n"
--                 (B8.unpack $ endPointAddressToByteString ourAddr)
--                 ourId
--                 theirId
          join $ withMVar (localEndPointState ourEp) $ \case
            LocalEndPointValid v -> 
                case theirAddress `Map.lookup` r of
                  Nothing  -> return (return ()) -- XXX: send message to the host
                  Just rep -> modifyMVar (remoteEndPointState rep) $ \case
                    RemoteEndPointFailed -> return (RemoteEndPointFailed, return ())
                    RemoteEndPointClosed -> throwM $ InvariantViolation "RemoteEndPoint should be valid or failed."
                    RemoteEndPointClosing{} -> throwM $ InvariantViolation "RemoteEndPoint should be valid or failed."
                    t@(RemoteEndPointValid (ValidRemoteEndPoint sock (Counter x m) s z)) -> do
                      case ourId `Map.lookup` m of
                          Nothing -> return (t, return ())     -- XXX: send message to the hostv
                          Just c  -> do
                            return (RemoteEndPointValid (ValidRemoteEndPoint sock (Counter x (ourId `Map.delete` m)) s (z+1))
                                   , do 
                                        modifyMVar_ (connectionState c) $ \case
                                          ZMQConnectionFailed -> return ZMQConnectionFailed
                                          ZMQConnectionInit -> return $ ZMQConnectionValid (ValidZMQConnection theirId)
                                          ZMQConnectionClosed -> do
                                              ZMQ.send sock [] $ encode' (MessageCloseConnection theirId)
                                              -- decrement value
                                              return ZMQConnectionClosed
                                          ZMQConnectionValid _ -> throwM $ InvariantViolation "RemoteEndPoint should be closed"
                                        void $ tryPutMVar (connectionReady c) ()
                                   )
                    RemoteEndPointPending p -> return (RemoteEndPointPending p, undefined)
              where 
                r = _localEndPointRemotes v
            LocalEndPointClosed -> return $ return ()
--          printf "[%s] message init connection ok                      [ok]\n"
--                          (B8.unpack $ endPointAddressToByteString ourAddr)
        MessageEndPointClose theirAddress True -> getRemoteEndPoint ourEp theirAddress >>= \case
          Nothing  -> return ()
          Just rep -> do
            onValidRemote rep $ \v ->
              ZMQ.send (_remoteEndPointChan v) [] (encode' $ MessageEndPointCloseOk $ localEndPointAddress ourEp)
            remoteEndPointClose True ourEp rep
        MessageEndPointClose theirAddress False -> getRemoteEndPoint ourEp theirAddress >>= \case
          Nothing  -> return ()
          Just rep -> do
            mst <- cleanupRemoteEndPoint ourEp rep Nothing
            case mst of
              Nothing -> return ()
              Just st -> do
                onValidEndPoint ourEp $ \v -> atomically $ writeTMChan (_localEndPointChan v) $
                   ErrorEvent $ TransportError (EventConnectionLost (localEndPointAddress ourEp)) "Exception on remote side"
                closeRemoteEndPoint ourEp rep st
        MessageEndPointCloseOk theirAddress -> getRemoteEndPoint ourEp theirAddress >>= \case
          Nothing -> return ()
          Just rep -> do
            state <- swapMVar (remoteEndPointState rep) RemoteEndPointClosed
            closeRemoteEndPoint ourEp rep state
      where
        ourAddr = localEndPointAddress ourEp
    finalizeEndPoint ourEp port pull = do
--      printf "[%s] finalize-end-point\n"
--             (B8.unpack $ endPointAddressToByteString $ _localEndPointAddress ourEp)
      join $ withMVar (localEndPointState ourEp) $ \case
        LocalEndPointClosed  -> afterP ()
        LocalEndPointValid v -> do
          writeIORef (_localEndPointOpened v) False
          return $ do
            tid <- Async.async $ finalizer pull ourEp
            void $ Async.mapConcurrently (remoteEndPointClose False ourEp)
                 $ _localEndPointRemotes v
            Async.cancel tid
            ZMQ.unbind pull (address ++ ":" ++ show port)
            ZMQ.close pull
      void $ swapMVar (localEndPointState ourEp) LocalEndPointClosed
    accure = do
      pull <- ZMQ.socket ctx ZMQ.Pull
      case authorizationType params of
          ZMQNoAuth -> return ()
          ZMQAuthPlain p u -> do
              ZMQ.setPlainServer True pull
              ZMQ.setPlainPassword (ZMQ.restrict p) pull
              ZMQ.setPlainUserName (ZMQ.restrict u) pull
      ZMQ.setSendHighWM (ZMQ.restrict (highWaterMark params)) pull
      ZMQ.setLinger (ZMQ.restrict (lingerPeriod params)) pull
      port <- ZMQ.bindFromRangeRandom pull address (minPort params) (maxPort params) (maxTries params)
      return (port, pull)

apiSend :: ZMQConnection -> [ByteString] -> IO (Either (TransportError SendErrorCode) ())
apiSend c@(ZMQConnection l e _ s _) b = do
   result <- trySome inner
   case result of
     Left ex -> do
       cleanup
       return $ Left $ TransportError SendFailed (show ex)
     Right x -> return x
  where
   inner = join $ withMVar (remoteEndPointState e) $ \x -> case x of
     RemoteEndPointFailed -> afterP $ Left $ TransportError SendFailed "Remote end point is failed."
     RemoteEndPointClosed -> afterP $ Left $ TransportError SendFailed "Remote end point is closed."
     RemoteEndPointClosing{} -> afterP $ Left $ TransportError SendFailed "Remote end point is closing."
     RemoteEndPointPending{} -> return $ yield >> inner
     RemoteEndPointValid v   -> withMVar s $ \case
       ZMQConnectionInit   -> return $ yield >> inner -- readMVar (connectionReady c) >> inner
       ZMQConnectionClosed -> afterP $ Left $ TransportError SendClosed "Connection is closed"
       ZMQConnectionFailed -> afterP $ Left $ TransportError SendFailed "Connection is failed"
       ZMQConnectionValid (ValidZMQConnection idx) -> do
         ZMQ.sendMulti (_remoteEndPointChan v) $ encode' (MessageData idx) :| b
         afterP $ Right ()
   cleanup = do
     cleanupRemoteEndPoint l e 
       (Just $ \v -> ZMQ.send (_remoteEndPointChan v) [] $ encode' (MessageEndPointClose (localEndPointAddress l) False))
     onValidEndPoint l $ \v -> atomically $ do
       writeTMChan (_localEndPointChan v) $ ErrorEvent $ TransportError
                   (EventConnectionLost (remoteEndPointAddress e)) "Exception on send."

-- 'apiClose' function is asynchronous, as connection may not exists by the
-- time of the calling to this function. In this case function just marks
-- connection as closed, so all subsequent calls from the user side will
-- "think" that the connection is closed, and remote side will be contified
-- only after connection will be up.
apiClose :: ZMQConnection -> IO ()
apiClose (ZMQConnection _ e _ s _) = join $ do
   modifyMVar s $ \case
     ZMQConnectionInit   -> return (ZMQConnectionClosed, return ())
     ZMQConnectionClosed -> return (ZMQConnectionClosed, return ())
     ZMQConnectionFailed -> return (ZMQConnectionClosed, return ())
     ZMQConnectionValid (ValidZMQConnection idx) -> do
       return (ZMQConnectionClosed, do
         modifyMVar_ (remoteEndPointState e) $ \case
           v@RemoteEndPointClosed    -> return v
           v@RemoteEndPointClosing{} -> return v
           v@RemoteEndPointFailed    -> return v
           v@RemoteEndPointValid{}   -> notify idx v
           v@(RemoteEndPointPending p) -> modifyIORef p (\xs -> notify idx : xs) >> return v
         )
  where
    notify _ RemoteEndPointFailed    = return RemoteEndPointFailed
    notify _ (RemoteEndPointClosing x) = return $ RemoteEndPointClosing x
    notify _ RemoteEndPointClosed    = return RemoteEndPointClosed
    notify _ RemoteEndPointPending{} = throwM $ InvariantViolation "RemoteEndPoint can't be pending."
    notify idx w@(RemoteEndPointValid (ValidRemoteEndPoint sock _ _ _)) = do
      ZMQ.send sock [] $ encode' (MessageCloseConnection idx)
      return w

apiConnect :: Context
           -> LocalEndPoint
           -> EndPointAddress
           -> Reliability
           -> ConnectHints
           -> IO (Either (TransportError ConnectErrorCode) Connection)
apiConnect ctx ourEp theirAddr reliability _hints = do
--  printf "[%s] apiConnect to %s\n"
--       (B8.unpack $ endPointAddressToByteString $ _localEndPointAddress ourEp)
--       (B8.unpack $ endPointAddressToByteString theirAddr)
    eRep <- createOrGetRemoteEndPoint ctx ourEp theirAddr
    case eRep of
      Left{} -> return $ Left $ TransportError ConnectFailed "LocalEndPoint is closed."
      Right rep -> do 
        conn <- ZMQConnection <$> pure ourEp
                              <*> pure rep
                              <*> pure reliability
                              <*> newMVar ZMQConnectionInit
                              <*> newEmptyMVar
        let apiConn = Connection 
              { send = apiSend conn
              , close = apiClose conn
              }
        join $ modifyMVar (remoteEndPointState rep) $ \w -> case w of
          RemoteEndPointClosed -> do
            return ( RemoteEndPointClosed
                   , return $ Left $ TransportError ConnectFailed "Transport is closed.")
          RemoteEndPointClosing x -> do
            return ( RemoteEndPointClosing x
                   , return $ Left $ TransportError ConnectFailed "RemoteEndPoint closed.")
          RemoteEndPointValid _ -> do
            s' <- go conn w
            return (s', waitReady conn apiConn)
          RemoteEndPointPending z -> do
            modifyIORef z (\zs -> go conn : zs)
            return ( RemoteEndPointPending z, waitReady conn apiConn)
          RemoteEndPointFailed ->
            return ( RemoteEndPointFailed
                   , return $ Left $ TransportError ConnectFailed "RemoteEndPoint failed.")
  where
    waitReady conn apiConn = join $ withMVar (connectionState conn) $ \case
      ZMQConnectionInit{}   -> return $ waitReady conn apiConn
      ZMQConnectionValid{}  -> afterP $ Right apiConn
      ZMQConnectionFailed{} -> afterP $ Left $ TransportError ConnectFailed "Connection failed."
      ZMQConnectionClosed{} -> throwM $ InvariantViolation "Connection closed."
    ourAddr = localEndPointAddress ourEp
    go conn s = tryPutMVar (connectionReady conn) () >> inner conn s
    inner _ RemoteEndPointClosed      = return RemoteEndPointClosed
    inner _ RemoteEndPointPending{}   = throwM $ InvariantViolation "Connection pending."
    inner _ (RemoteEndPointClosing x) = return $ RemoteEndPointClosing x
    inner _ RemoteEndPointFailed      = return RemoteEndPointFailed
    inner conn (RemoteEndPointValid (ValidRemoteEndPoint sock (Counter i m) s z)) = do
        ZMQ.send sock [] $ encode' (MessageInitConnection ourAddr i' reliability)
        return $ RemoteEndPointValid (ValidRemoteEndPoint sock (Counter i' (Map.insert i' conn m)) s z)
      where i' = succ i


getRemoteEndPoint :: LocalEndPoint -> EndPointAddress -> IO (Maybe RemoteEndPoint)
getRemoteEndPoint ourEp theirAddr = do
    withMVar (localEndPointState ourEp) $ \case
      LocalEndPointValid v -> return $ theirAddr `Map.lookup` (_localEndPointRemotes v)
      LocalEndPointClosed  -> return Nothing

createOrGetRemoteEndPoint :: Context
                          -> LocalEndPoint
                          -> EndPointAddress
                          -> IO (Either ZMQError RemoteEndPoint)
createOrGetRemoteEndPoint ctx ourEp theirAddr = join $ do
--    printf "[%s] apiConnect to %s\n"
--           saddr
--           (B8.unpack $ endPointAddressToByteString theirAddr)
    modifyMVar (localEndPointState ourEp) $ \case
      LocalEndPointValid v@(ValidLocalEndPoint _ _ m _ o) -> do
        opened <- readIORef o
        if opened
        then do
          case theirAddr `Map.lookup` m of
            Nothing -> create v m
            Just rep -> do
              withMVar (remoteEndPointState rep) $ \case
                RemoteEndPointFailed -> create v m
                _ -> return (LocalEndPointValid v, return $ Right rep)
        else return (LocalEndPointValid v, return $ Left $ IncorrectState "EndPointClosing")
      LocalEndPointClosed ->
        return  ( LocalEndPointClosed
                , return $ Left $ IncorrectState "EndPoint is closed" 
                )
  where
    create v m = do
--    printf "[%s] apiConnect: remoteEndPoint not found, creating %s\n"
--           (B8.unpack $ endPointAddressToByteString $ _localEndPointAddress ourEp)
--           (B8.unpack $ endPointAddressToByteString theirAddr)
      push <- ZMQ.socket ctx ZMQ.Push
      state <- newMVar . RemoteEndPointPending =<< newIORef []
      let rep = RemoteEndPoint theirAddr state
      return ( LocalEndPointValid v{ _localEndPointRemotes = Map.insert theirAddr rep m}
             , initialize push rep >> return (Right rep))
    ourAddr = localEndPointAddress ourEp
    initialize push rep = do
      lock <- newEmptyMVar
      x <- Async.async $ do
         takeMVar lock
         ZMQ.connect push (B8.unpack $ endPointAddressToByteString theirAddr)
      monitor <- ZMQ.monitor [ZMQ.ConnectedEvent] ctx push
      putMVar lock ()
      r <- Async.race (threadDelay 1000000) (monitor True)
      monitor False
      case r of
        Left _ -> do
          _ <- swapMVar (remoteEndPointState rep) RemoteEndPointFailed
          Async.cancel x
          ZMQ.close push
        Right _ -> do
          ZMQ.send push [] $ encode' $ MessageConnect ourAddr
          let v = ValidRemoteEndPoint push (Counter 0 Map.empty) Set.empty 0
          modifyMVar_ (remoteEndPointState rep) $ \case
            RemoteEndPointPending p -> foldM (\y f -> f y) (RemoteEndPointValid v) . Prelude.reverse =<< readIORef p
            RemoteEndPointValid _   -> throwM $ InvariantViolation "RemoteEndPoint valid."
            RemoteEndPointClosed    -> return RemoteEndPointClosed
            RemoteEndPointClosing x -> return (RemoteEndPointClosing x)
            RemoteEndPointFailed    -> return RemoteEndPointFailed

-- | Close all endpoint connections, return previous state in case
-- if it was alive, for further cleanup actions. 
cleanupRemoteEndPoint :: LocalEndPoint
                      -> RemoteEndPoint
                      -> (Maybe (ValidRemoteEndPoint -> IO ()))
                      -> IO (Maybe RemoteEndPointState)
cleanupRemoteEndPoint lep rep actions = modifyMVar (localEndPointState lep) $ \case
    LocalEndPointValid v -> do
      oldState <- swapMVar (remoteEndPointState rep) newState
      case oldState of
        RemoteEndPointValid w -> do
          let (Counter _ cn) = _remoteEndPointPendingConnections w
          void $ traverse (\c -> void $ swapMVar (connectionState c) ZMQConnectionFailed) cn
          cn' <- foldM 
               (\(Counter i' cn') idx -> case idx `Map.lookup` cn of
                   Nothing -> return (Counter i' cn')  
                   Just c  -> do
                     void $ swapMVar (connectionState c) ZMQConnectionFailed
                     return $ Counter i' (Map.delete idx cn')
               ) 
               (_localEndPointConnections v)
               (Set.toList (_remoteEndPointIncommingConnections w))
          case actions of
            Nothing -> return ()
            Just f  -> f w
          return ( LocalEndPointValid v { _localEndPointConnections=cn' }
                 , Just oldState)
        _ -> return (LocalEndPointValid v, Nothing)
    c -> return (c, Nothing)
  where
    newState = RemoteEndPointFailed

-- | Close, all network connections.
closeRemoteEndPoint :: LocalEndPoint -> RemoteEndPoint -> RemoteEndPointState -> IO ()
closeRemoteEndPoint lep rep state = step1 >> step2 state
  where
   step1 = modifyMVar_ (localEndPointState lep) $ \case
     LocalEndPointValid v -> return $
       LocalEndPointValid v{_localEndPointRemotes=Map.delete
                               (remoteEndPointAddress rep) 
                               (_localEndPointRemotes v)}
     c -> return c
   step2 (RemoteEndPointValid v) = do
      ZMQ.disconnect (_remoteEndPointChan v) (B8.unpack . endPointAddressToByteString $ remoteEndPointAddress rep)
      ZMQ.close (_remoteEndPointChan v)
   step2 (RemoteEndPointClosing (ClosingRemoteEndPoint sock rd)) = do
     _ <- readMVar rd
     ZMQ.disconnect sock (B8.unpack . endPointAddressToByteString $ remoteEndPointAddress rep)
     ZMQ.close sock
   step2 _ = return ()


remoteEndPointClose :: Bool -> LocalEndPoint -> RemoteEndPoint -> IO ()
remoteEndPointClose silent lep rep = do
--   printf "[???] remoteEndPointClose %s\n"          
--          (B8.unpack $ endPointAddressToByteString $ lAddr)
--          (B8.unpack $ endPointAddressToByteString $ remoteEndPointAddress rep)
   join $ modifyMVar (remoteEndPointState rep) $ \o -> case o of
     RemoteEndPointFailed        -> return (o, return ())
     RemoteEndPointClosed        -> return (o, return ())
     RemoteEndPointClosing (ClosingRemoteEndPoint _ l) -> return (o, void $ readMVar l)
     RemoteEndPointPending _ -> closing undefined o -- XXX: store socket, or delay
     RemoteEndPointValid v   -> closing (_remoteEndPointChan v) o
 where
   closing sock old = do
     lock <- newEmptyMVar  
     return (RemoteEndPointClosing (ClosingRemoteEndPoint sock lock), go lock old)
   go lock old@(RemoteEndPointValid (ValidRemoteEndPoint c _ s i)) = do
     -- close all connections
     void $ cleanupRemoteEndPoint lep rep Nothing
     withMVar (localEndPointState lep) $ \case
       LocalEndPointClosed -> return ()
       LocalEndPointValid v -> do
         -- notify about all connections close (?) do we really want it?
         void $ traverse (atomically . writeTMChan (_localEndPointChan v) . ConnectionClosed) (Set.toList s)
         -- if we have outgoing connections, then we have connection error
         when (i > 0) $ atomically
                      $ writeTMChan (_localEndPointChan v)
                      $ ErrorEvent $ TransportError (EventConnectionLost (remoteEndPointAddress rep)) "Remote end point closed."
     -- notify other side about closing connection
     unless silent $ do
       ZMQ.send  c [] (encode' (MessageEndPointClose (localEndPointAddress lep) True))
       yield
       Async.race (readMVar lock) (threadDelay 1000000)
       tryPutMVar lock ()
       closeRemoteEndPoint lep rep old
       return ()       
   go _ _ = return ()    

connectionCleanup :: RemoteEndPoint -> ConnectionId -> IO ()
connectionCleanup rep cid = modifyMVar_ (remoteEndPointState rep) $ \case
   RemoteEndPointValid v -> return $
      RemoteEndPointValid v{_remoteEndPointIncommingConnections = Set.delete cid (_remoteEndPointIncommingConnections v)}
   c -> return c
         
encode' :: Binary a => a -> ByteString
encode' = B.concat . BL.toChunks . encode

decode' :: Binary a => ByteString -> a
decode' s = decode . BL.fromChunks $ [s]

onValidEndPoint :: LocalEndPoint -> (ValidLocalEndPoint -> IO ()) -> IO ()
onValidEndPoint lep f = withMVar (localEndPointState lep) $ \case
   LocalEndPointValid v -> f v
   _ -> return ()

onValidRemote :: RemoteEndPoint -> (ValidRemoteEndPoint -> IO ()) -> IO ()
onValidRemote rep f = withMVar (remoteEndPointState rep) $ \case
  RemoteEndPointValid v -> f v
  _ -> return ()

afterP :: a -> IO (IO a)
afterP = return . return

trySome :: IO a -> IO (Either SomeException a)
trySome f = try f >>= \case
  Left e -> case (fromException e) of
    Just m  -> throwM (m::AsyncException)
    Nothing -> return $ Left e
  Right x -> return $ Right x

-- | Break endpoint connection.
breakConnection :: ZMQTransport
                -> EndPointAddress
                -> EndPointAddress
                -> IO ()
breakConnection zmqt from to = join $ withMVar (_transportState zmqt) $ \case
  TransportValid v -> case from `Map.lookup` _transportEndPoints v of
    Nothing -> afterP ()
    Just x  -> withMVar (localEndPointState x) $ \case
      LocalEndPointValid w -> case to `Map.lookup` _localEndPointRemotes w of
        Nothing -> afterP ()
        Just y  -> return $ remoteEndPointClose True x y
      LocalEndPointClosed   -> afterP ()
  TransportClosed -> afterP ()
